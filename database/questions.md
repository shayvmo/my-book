## 疑问汇总



**1、列举几个 MySQL 索引失效的情况？该如何优化这些情况？**

- 列参与了数学运算或者函数；
- 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)；
- 对于多列索引，不符合最左匹配的命中规则；
- like查询是以%开头，也就是前导模糊查询
- 如果直接查比用索引快，那么数据库会自动选择最优方式，不用索引；
- in 和 not in 也要慎用，否则会导致全表扫描，负向not in 不能使用索引，in 最好是主键
- 数据区分不明显的不建议创建索引，例如 user 的性别
- 不要让数据库做强制类型转换，例如：where id = '1'; 
- 连表字段类型要相同



**2、MySQL 索引都有哪些？InnoDB 索引是用的什么数据结构，为什么使用这种数据结构？**

主键索引、唯一索引、哈希索引、前缀索引、覆盖索引

- B-Tree索引：全值匹配，最左前缀匹配，列前缀匹配，范围值
- 哈希索引：MyISAM 特有，且支持非唯一哈希索引，多个列的哈希值相同，以链表方式存放到同一个哈希条目
- 全文索引：match against
- 空间数据索引 ：MyISAM



使用B+树作为索引的数据结构，主要考虑的是IO影响。因为B+ 树只有叶子节点存储数据，B树内部也存储数据。在查询相同数据量的情况下，B树高度更高，IO次数更多，然后只能一点点加载数据页。 B树的话，所有的节点都是数据地址。需要在内部节点和叶子之间去查询数据。b树的分支节点也有数据。 b树范围查询只能中序遍历。

B+树只有叶子节点数据，而且叶子节点之间由链表构成的，在叶子节点直接顺序查询会比较快。b+树的数据都集中在叶子节点。分支节点只负责索引。b+树的层高 会小于 B树 平均的Io次数会远大于 B+树（因为B+树是顺序查找）b+树更擅长范围查询。叶子节点 数据是按顺序放置的双向链表。 b+树可以把索引完全加载至内存中。支持多路，多路的好处：可以每次只加载一个节点的数据进去，因为内存的容量是有限的。



**3、MySQL 主从复制是如何实现的？如果从节点挂了，重新启动从节点，如何保持数据一致性？如何解决数据同步延迟问题？**

主从复制整个过程主要涉及三个线程：binlog 线程、I/O 线程、SQL 线程

- binlog 线程：主服务器把数据更改记录保存到二进制日志 binlog 。
- I/O 线程：从服务器把主库的binlog 复制到自己的中继日志 relay log 中。
- SQL 线程：从库读取中继日志 relay log，进行 SQL 语句重放。

1）重新启动从结点，观察 MySQL 错误日志，InnoDB 在恢复过程中会打印出它的恢复点的二进制日志坐标，可以用这个值决定从库指向主库的偏移量

2）从头开始复制binlog

3）使用 Percona Toolkit 的 pt-table-checksum 和 pt-slave-restart 工具检查主从一致性。





主从延迟问题：

- MySQL5.7 后并行复制



**4、说说你优化 SQL 语句的几种思路有哪些？**

- 反向查询不能使用索引，in 和 not in 一类
- 前导模糊查询不能使用索引， like '%a%' 不能使用索引
- 字段的默认值不要为null
- 数据区分不明显的列不需要建立索引
- 字段进行计算不能命中索引
- 索引的最左前缀匹配
- 不要让数据库做强制类型转换 id = '1';
- 连表字段类型相同



**5、说说 MySQL 中的锁有哪些？之间的区别？**

级别：行级锁和表级锁

| 锁                    | 描述                                                         | 级别   |
| --------------------- | ------------------------------------------------------------ | ------ |
| 排它锁 X 锁，也称写锁 | 数据对象 A 加了 X 锁后，可以对 A 进行读取和更新。加锁期间不能加任何锁 |        |
| 共享锁 S 锁，也称读锁 | 加了 S 锁后，可以进行读取操作，但是不能进行更新操作。加锁期间其他事务可以加 S 锁，但是不能加 X 锁 |        |
| 意向排它锁 IX         |                                                              | 表级锁 |
| 意向共享锁 IS         |                                                              | 表级锁 |

兼容关系

| -    | X    | IX   | S    | IS   |
| ---- | ---- | ---- | ---- | ---- |
| X    | x    | x    | x    | x    |
| IX   | x    | √    | x    | √    |
| S    | x    | x    | √    | √    |
| IS   | x    | √    | √    | √    |



**6、MySQL 中的事务了解吗？说说其 4 大特性？**

A 原子性：事务是最小的分割单元，要么全部成功，要么全部失败。

C 一致性：数据库在事务执行前后保持一致。

I 隔离性：一个事务的修改在未提交前不可见。

D 持久性：事务一旦提交后，将永久保存在数据库中。



**7、事务中隔离性，有几种情况？这几种情况分别会产生什么问题？**

| 隔离级别                  | 描述                                       | 脏读 | 不可重复读 | 幻影读 |
| ------------------------- | ------------------------------------------ | ---- | ---------- | ------ |
| Read Uncommitted 未提交读 | 事务未提交的修改，其他事务可见             | √    | √          | √      |
| Read Committed 提交读     | 事务只能读取已提交的事务的修改             | ×    | √          | √      |
| Repeatable Read 可重复读  | 同一个事务中，多次读取同样的数据，结果一样 | x    | x          | √      |
| Serializable 串行化       | 事务串行执行                               | x    | x          | x      |



**8、MySQL 中 MVVC 实现的原理是怎么样的？**

每行记录后面都保存两个隐藏的列，用于存储两个版本号：

- 创建版本号：创建行快照的时间
- 删除版本号：该快照的删除时间

两个时间，并不是实际的时间值，而是系统版本号。每开始一个新的事务，版本号自动递增。事务开始时刻的版本号作为事务的版本号，用来比对查询到的每行记录的版本号。

Repeatable Read 级别下，MVCC具体操作：

SELECT：

- 创建版本号必须小于当前事务版本号，因为如果创建版本号大于当前事务版本号的话，证明该快照数据已经被其他事务修改，也不能去读取它。
- 删除版本号必须未定义或大于当前事务版本号，因为如果小于当前版本号，证明该快照数据已被删除，不应该去读取

INSERT：

- 将当前系统版本号作为该数据快照的创建版本号

UPDATE：

- 当前系统版本号作为更新前的数据快照的删除版本号，并作为更新后数据快照的创建版本号。可以理解为，先DELETE，后执行INSERT

DELETE：

- 将当前系统版本号作为数据快照的删除版本号



快照读和当前读



**9、三大范式**

第一范式：属性不可分   1-1

第二范式：每个非主属性完全函数依赖于键码  1-n

第三范式：非主属性不传递函数依赖于键码 n-n