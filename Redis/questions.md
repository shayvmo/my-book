## 疑问汇总



**什么是Redis？Redis 为什么快？**

内存高速缓存数据库。Remote Dictionary Server （远程数据服务），C 语言编写的，key-value 存储系统，支持丰富的数据类型。

快的原因：

- 基于内存，无需磁盘IO
- 单线程，避免不必要的上下文切换和竞争，无需考虑锁的问题
- C 语言开发，接近底层操作
- 多路 I/O 复用模型，非阻塞IO
  - 多路复用。让单个线程高效的处理多个网络连接请求
  - 非阻塞IO 内部实现采用 epoll 
- 数据结构简单





**平常使用 Redis 都是在哪些场景？**

- 热点数据的缓存
  - 读取数据先读取缓存，缓存没有再读取数据库，这时候需要注意缓存击穿。
- 限时业务的运用
  - 手机验证码，一些限时活动等
- 计数器
  - 秒杀限购
  - 接口限制请求次数等
- 分布式锁
  - setnx：set if not exists 
  - 争抢数据
- 排行榜 zset
- 点赞、好友等相互关系的存储 : sort
- 简单队列



**Redis 的持久化有哪几种？有什么区别？实现的原理是怎样的？**

RDB：把当前进程数据生成快照保存到磁盘

- 手动触发和自动触发



手动触发：`save`  和 `bgsave`

- save 阻塞当前服务器，直到RDB过程结束
- bgsave fork 子进程，子进程负责RDB过程

自动触发：redis.conf 中配置RDB

```
# 周期性执行条件的设置格式为
save <seconds> <changes>

# 默认的设置为：
save 900 1
save 300 10
save 60 10000

# 以下设置方式为关闭RDB快照功能
save ""
```

- 900 秒内有1条key信息发生变化，则进行快照
- 300 秒内有10条key信息发生变化，则进行快照
- 60 秒内有10000条key信息发生变化，则进行快照



AOF：写后日志，即先写内存，后写日志







**Redis 的事务了解吗？事务都有哪些注意的地方？**





**Redis 都有哪些数据类型？你是怎么选择数据类型的？底层的数据结构是怎么样的？**

| 类型          | 结构存储的值                  | 结构读写能力                                              | 底层数据结构        | 应用场景                  |
| ------------- | ----------------------------- | --------------------------------------------------------- | ------------------- | ------------------------- |
| String 字符串 | 字符串、整数、浮点数          | 字符串操作；整数或浮点数的自增或自减操作                  | SYS                 | 缓存、计数器、session     |
| List 列表     | 链表， 每个节点包含一个字符串 | 链表的push、 pop 操作，读取单个或多个元素；根据值查找元素 | QuickList           | TimeLine时间轴 、消息队列 |
| Set 集合      | 包含字符串的无序集合          | 交集，并集，差集等                                        | HashTable，IntSet   | 标签，收藏                |
| Hash 散列     | 键值对的无序散列表            | 添加，删除，获取                                          | HashTable， ZipList | 缓存，用户信息等          |
| Zset 有序集合 | 存储键值对                    | 有序集合，可根据分值范围获取元素                          | ZipList，ZSkipList  | 排行榜                    |



使用列表的技巧

- lpush + lpop = 栈
- lpush + rpop = 队列
- lpush + ltrim = 有限集合
- lpush + brpop = 消息队列



SYS  ：简单动态字符串

ZipList：压缩列表

QuickList：快表

Dict：字典/哈希表

IntSet：整数集

ZSkipList：跳表



**Redis 能够实现命令批处理吗？**





**Redis 的哨兵机制了解吗？实现原理是怎么样的？**





**Redis 的主从复制实现原理是怎么样的？如何保证数据一致性？数据延迟又该如何处理？**





**利用 Redis 如何实现队列功能？**

list



**消息发布与订阅有使用过吗？怎么使用的？中间又遇到过什么问题吗？**

无法持久化，如果出现网络异常，redis 宕机，消息就会被抛弃

如果发布者下线，订阅者消息丢失





**如何解决缓存穿透、击穿和雪崩问题？**

**缓存穿透**：请求缓存和数据库都没有的数据，频繁请求导致数据库压力过大

- 接口层校验，如用户鉴权等

- 缓存取不到的数据，有效时间设置短一点

- 布隆过滤器：快速判断是否一个key 有存在，避免直接暴力访问数据库。hash  set 实现

  

**缓存击穿**：缓存中没有，数据库中有的数据。失效瞬间，数据并发请求数据库，造成问题

缓存失效，瞬间并发请求数据库，导致数据库压力过大。

- 热点数据永不过期
- 接口限流，熔断，降级
- 互斥锁 setnx 



**缓存雪崩**：大量缓存数据同一时间失效，所有请求直接请求到数据库，瞬间导致数据库宕机。

- 热点数据永不过期
- 过期时间设置随机时间



**Redis 作为一个内存型数据库，如何更好的解决内存的占用？**

支持八种淘汰策略。

- 不淘汰
  - no-eviction （4.0后默认）
- 对设置了过期时间的数据中进行淘汰
  - 随机：volatile-random
  - ttl：volatile-ttl，相比随机淘汰，多了过期时间这个参考指标，越快过期的，越优先选择
  - lru：volatile-lru
  - lfu：volatile-lfu
- 全部数据进行淘汰
  - 随机：allkeys-random
  - lru：allkeys-lru
  - lfu：allkeys-lfu



LRU算法

Least Recently Used： 最近最少使用，是一种缓存置换算法。

如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。



LFU算法

Least Frequently Used：最近最频繁使用，根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。



定期删除和惰性删除





**数据库和缓存一致性**

左耳朵耗子的文章：[缓存更新的套路](https://coolshell.cn/articles/17416.html)

更新缓存的的Design Pattern有四种：

- Cache aside
- Read through
- Write through
- Write behind caching



Cache aside ：

- **读的时候**，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。

- **更新的时候**，先更新数据库，然后再删除缓存。

  

具体逻辑：

- **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- **命中**：应用程序从cache中取数据，取到后返回。
- **更新**：先把数据存到数据库中，成功后，再让缓存失效。



情况：删除缓存失败

方案一：队列 + 重试机制

方案二：异步更新缓存（基于订阅 binlog 的同步机制）