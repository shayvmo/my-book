

### 类与对象

最近更新：2020年11月27日

---

【目录】

[TOC]

---



创建对象

```java
// 类名 对象名 = new 类名();
Employee employee = new Employee();
```



对象实例化过程

- **声明对象：** 在内存的栈空间执行。Employee employee;
- **实例化对象：**在内存的堆空间执行。new Employee();



java 中，最简单的类定义形式为：

```java
class className
{
	constructor1
    constructor2
    ...
    ...
    method1
    method2
    ...
    ...
    field1
    field2
}
```



#### 【构造器】

- 构造器与类同名
- 每个类可以有1个以上的构造器
- 构造器可以有0个、1个或多个参数
- 构造器没有返回值
- 构造器总是伴随着new操作一起调用



#### 【封装】

> 类的基本作用就是封装代码。封装将类的一些特征和行为**隐藏**在类内部，不允许类外部直接访问。
>
> 通过类提供的方法来实现对隐藏信息的操作和访问。**隐藏**了对象的信息，**留出**了访问的接口。





```java
class Employee
{
	...
	public Date getHireDay()
	{
		return hireDay;
	}
	...
	private Date hireDay;
}

// 这样会破坏封装性
Employee paul = ...;
Date d = paul.getHireDay();
double tenYearsInMillSeconds = 10 * 365.25 * 24 * 60 * 60 * 1000;
d.setTime(d.getTime() - (long) tenYearsInMillSeconds);

// d 和 paul.hireDay 引用同一个对象,直接造成 d 调用修改器修改了成员的 private 状态
```

【！！！】 如果需要返回一个可变对象的引用，应该首先对它进行克隆。

```java
// 修改后代码
class Employee
{
	...
	public Date getHireDay()
	{
		return (Date) hireDay.clone();
	}
	...
	private Date hireDay;
}
```



【final 实例域】

> 对象构建后，该值就不会再被修改



【静态域与静态方法】

```java
priavte static int id = 1;// 静态域
public static int getId()
{
    return id;
}
```



【Factory 方法】

> `NumberFormat` 类使用`factory `方法产生不同风格的格式对象。

```java
NumberFormat currenyFormatter = NumberFormat.getCurrenyInstance();
double x = 0.1;
System.out.println(currenyFormatter.format(x));// $0.10
```



【Main 方法】

>  `main` 方法作为程序的启动入口，静态调用，并创建所需的对象



#### 【继承】

> 单一继承，一个子类只能拥有一个父类，一个父类可以拥有多个子类。
>
> 另外，所有的类都继承` java.lang.Object  `。除了`Object` 类之外，所有类都必须有一个父类。定义类时，如果没有显示定义父类，则默认继承` Object`类



##### 【方法重写】

>  方法重写发生在子类和父类之间。
>
> 如果一个类从它的父类继承了一个方法，如果这个方法没有被标记为 `final` 或 `static`，就可以对这个方法进行重写。重写的好处是：能够定义特定于子类类型的行为，这意味着子类能够基于要求来实现父类的方法。



【！！！！】开发中，在要重写的方法上面注解 `@Override`，可以让编译器帮助检查重写是否正确。建议所有重写的方法都加上注解

```java
public class Pet {
    ...
  	// 叫喊
    public void shout() {
        System.out.println("宠物会叫");
    }
}

class Dog extends Pet{
	// 重写 shout 方法
  	public void shout() {
        System.out.println(this.getName() + "汪汪汪地叫~");
    }
}

class Cat extends Pet{
  	@Override  // 使用注解
  	public void shout() {
        System.out.println(this.getName() + "喵喵喵地叫~");
    }
}

```



##### 【方法重写规则】

- 重写方法的参数列表应该与原方法完全相同；
- 返回值类型应该和原方法的返回值类型一样或者是它在父类定义时的子类型；
- 重写方法访问级别限制不能比原方法高。例如：如果父类方法声明为公有的，那么子类中的重写方法不能是私有的或是保护的。具体限制级别参考访问修饰符；
- 只有被子类继承时，方法才能被重写；
- 方法定义为 `final`，将不能被重写（`final` 关键字将在本节后面讲到）；
- 一个方法被定义为 static，将使其不能被重写，但是可以重新声明；
- 一个方法不能被继承，那么也不能被重写；
- 和父类在一个包中的子类能够重写任何没有被声明为 private 和 final 的父类方法；
- 和父类不在同一个包中的子类只能重写 non-final 方法或被声明为 public 或 protected 的方法；
- 一个重写方法能够抛出任何运行时异常，不管被重写方法是否抛出异常。然而重写方法不应该抛出比被重写方法声明的更新更广泛的已检查异常。重写方法能够抛出比被重写方法更窄或更少的异常；
- 构造方法不能重写。



##### 【方法重写和方法重载的区别】

Java 中的方法重写（`Overriding`）是说子类重新定义了父类的方法。方法重写必须有相同的**方法名，参数列表和返回类型**。覆盖者访问修饰符的限定**大于等于**父类方法。

而方法重载（`Overloading`）发生在**同一个类**里面两个或者是多个方法的方法名相同但是参数不同的情况。



##### 【访问修饰符】

Java 一共提供了 4 种访问修饰符：

1. **private**：私有的，只允许在本类中访问；
2. **protected**：受保护的，允许在同一个类、同一个包以及不同包的子类中访问；
3. **默认的**：允许在同一个类，同一个包中访问；
4. **public**：公共的，可以再任何地方访问。



##### 【super 关键字】

`super` 是用在子类中的，目的是访问**直接父类**的变量或方法。注意：

- super 关键字只能调用父类的 `public` 以及 `protected` 成员；
- super 关键字可以用在子类构造方法中调用父类构造方法；
- super 关键字不能用于静态 (`static`) 方法中。



1、调用父类构造方法

>  `super(参数列表)`

```java
public Pet(String name) {
    System.out.println("宠物实例被创建了，宠物名字为" + name);
}
public Dog(String name) {
  	super(name);
  	System.out.println("小狗实例被创建了");
}
// 宠物实例被创建了，宠物名字为花花
// 小狗实例被创建了

```



2、调用父类属性

>  `super.成员变量名`

```java
class Pet {
  	protected String birthday;
}

class Dog extends Pet {
  	public Dog() {
  	    System.out.println("宠物生日：" + super.birthday);
    }
}
```



3、调用父类方法

> super.方法名(参数列表)



```java
class Pet {
  	public void eat() {
      	System.out.println("宠物吃东西");
    }
}

class Cat extends Pet{
  	public void eat() {
      	// 在 eat 方法中调用父类 eat 方法
      	super.eat();
      	System.out.println("小猫饭量很小");
    }
}

class Test {
  	public static void main(String[] args) {
      	Cat cat = new Cat();
      	cat.eat();
    }
}

// 宠物吃东西
// 小猫饭量很小

```



##### 【super 和 this 】

`this` 关键字指向**当前类对象的引用**，它的使用场景为：

- 访问当前类的成员属性和成员方法；
- 访问当前类的构造方法；
- 不能在静态方法中使用。

`super` 关键字指向**父类对象的引用**，它的使用场景为：

- 访问父类的成员属性和成员方法；
- 访问父类的构造方法；
- 不能在静态方法中使用。

另外，需要注意的是，在构造方法调用时，super 和 this 关键字不能同时出现。



##### 【final 关键字】

`final` 关键字可以作用于类、方法或变量，分别具有不同的含义。在使用时，必须将其放在变量类型或者方法返回之前，建议将其放在访问修饰符和 `static` 关键字之后，例如：

```java
// 定义一个常量
public static final int MAX_NUM = 50;

```

- `final` 作用于类， 则该类不能被继承
- `final` 作用于方法，则该方法不能被重写
- `final` 作用于变量，则该变量在初始化之后不能被修改





#### 【多态】

> 多态顾名思义就是**多种形态**，是指对象能够有多种形态。在面向对象中最常用的多态性发生在当**父类引用指向子类对象**时。
>
> 在面向对象编程中，所谓多态意指相同的消息给予不同的对象会引发不同的动作。换句话说：多态意味着允许不同类的对象对同一消息做出不同的响应。



实现多态的条件

- 满足继承关系
- 要有重写
- 父类引用指向子类对象



```java
class Pet {
  	// 定义方法 eat
  	public void eat() {
      	System.out.println("宠物吃东西");
    }
}
class Dog extends Pet { // 继承父类
  	// 重写父类方法 eat
  	public void eat() {
      	System.out.println("狗狗吃狗粮");
    }
}
子类Cat继承Pet
class Cat extends Pet { // 继承父类
  	// 重写父类方法 eat
   	public void eat() {
      	System.out.println("猫猫吃猫粮");
    }
}

public class PetTest {
    public static void main(String[] args) {
        Pet pet = new Pet();// 向上转型
        Pet dog = new Dog();
        Pet cat = new Cat();
        pet.eat();
        dog.eat();
        cat.eat();

    }
}

```



##### 【向上转型】

在代码中，`Pet dog = new Dog();`、`Pet cat = new Cat();`这两个语句，把`Dog`和`Cat`对象转换为`Pet`对象，这种把一个子类对象转型为父类对象的做法称为**向上转型**。父类引用指向了子类的实例。也就实现了多态。



##### 【向下转型】

向上转型是父类引用指向子类实例，那么如何让**子类引用指向父类实例**呢？使用**向下转型**就可以实现。向下转型也被称为强制类型转换。

```java
// 为Cat类增加run方法
class Cat extends Pet { // 继承父类
  	// 重写父类方法 eat
   	public void eat() {
      	System.out.println("猫猫吃猫粮");
    }
  	
  	public void run() {
      	System.out.println("猫猫跑步");
    }
  
  	public static void main(String[] args) {    	
      	// 实例化子类
      	Pet cat = new Cat();
      	// 强制类型转换，只有转换为Cat对象后，才能调用其下面的run方法
      	Cat catObj = (Cat)cat;
      	catObj.run();
    }
}

```

【！！！】使用向下转型的时候，要注意：**不能将父类对象转换为子类类型，也不能将兄弟类对象相互转换**。



##### 【`instanceof `运算符】

> `instanceof`运算符用来检查对象引用是否是类型的实例，或者这个类型的子类，并返回布尔值。如果是返回`true`，如果不是返回`false`。
>
> 通常可以在运行时使用 `instanceof` 运算符指出某个对象是否满足一个特定类型的实例特征

```java
<对象引用> instanceof 特定类型
```

在向下转型之前，判断类型，增强安全性

```java
Pet pet = new Cat();
if (pet instanceof Cat) {
		// 将父类转换为子类
		Cat cat = (Cat) pet;
}

```











[imooc 参考地址](http://www.imooc.com/wiki/javalesson/polymorphism.html)

php 可以使用 implement 实现多态